
# CSP2021-训练-01

难度系数-$1475$

**一．题目概况**

| 中文题目名称 |  坏掉的键盘  | 二元回文 | 最小化整数 |  工资变动  |
| :----------: | :-------: | :---------: | :-------: | :----------: |
| 可执行文件名 | keyboard.cpp | binary.cpp | integer.cpp | salary.cpp |
|  输入文件名  | keyboard.in | binary.in | integer.in | salary.in |
|  输出文件名  | keyboard.out | binary.out | integer.out | salary.out |
|   时间限制   |  1000ms  |   2000ms   |   2000ms   |  3000ms  |
|   空间限制   | 256M   |   256M   |   256M   |   256M    |

**二．注意事项：**
1、文件名（程序名和输入输出文件名）必须使用英文小写。
2、C/C++中函数main()的返回值类型必须是int，程序正常结束时的返回值必须是 0。
3、结果比较方式 ： 全文比较（过滤行末空格及文末回车）  。
4、特别提醒：评测在当前最新公布的 $NOI$ $Linux$ 下进行。
5、本次测试需要使用文件读写。

<div STYLE="page-break-after: always;"></div> 
## 1 坏掉的键盘  （keyboard）
时间限制：$ 1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

最近，$Polycarp$发现他的键盘上的一些按键出现了问题。简单来说，我们假设$Polycarp$的键盘上只有$26$个按键（对应$26$个拉丁字母）。每一个按钮不是正常工作就是发生了故障。

为了找到哪些按键是出现问题的，$Ploycrap$按照一定顺序按下了一些字母，在屏幕上出现了一个字符串。当$Polycarp$按下一个带有字母$c$的按键的时候，就会发生以下两种情况的一种：

- 如果这个按键正常工作，那么$Polycarp$打出的字符串的结尾就会多出**一个**字母$c$。
- 如果这个按键出现了问题，那么$Polycarp$打出的字符串的结尾就会多出**两个**字母$c$。

举例来说，假设带有字母$a$和$c$的按键正常工作，而带有$b$的按键发生故障。如果$Polycarp$按照$a,b,a,c,a,b,a$的顺序按下按键，那么屏幕上的字符串就会按照：$a -> abb -> abbac ->abbaca->abbacabb->abbacabba$变化。

现在给你一个在$Polycrap$一番按键之后得到的字符串，请你帮他找出来有哪些按键可以确定是正常工作的（换言之，如果这些按键不能正常工作，则不会出现这个字符串）。

您可以假设在$Polycarp$键入字符串的时候按钮都没有出现故障。每一个按钮要么在整个过程中都可以正常工作，要么在整个过程中都出现问题。

### 输入格式

第一行包含一个整数 $t ( 1 \le t \le 100 )$ — 输入中的测试用例数。

然后是测试用例。 每个测试用例由一行表示，其中包含由不少于 $1$ 个且不超过 $500$ 个小写拉丁字母组成的字符串 $s$。

### 输出格式

对于每个测试用例，打印一行包含字符串 $res$ 。 字符串 $res$ 应包含与按字母顺序正确工作的按钮相对应的所有字符，没有任何分隔符或重复。 如果所有按钮都可能发生故障，$res$ 应为空。

### **输入 #1**
```
4
a
zzaaz
ccff
cbddbb
```

### **输出 #1**
```
a
z

bc
```

### 数据范围

### 

对于$30\%$的数据

对于$100\%$的数据$1 \le t \le 100;$  字符串$s$由拉丁字母组成 $(1\leq s\leq 500)$



<div STYLE="page-break-after: always;"></div> 

## 2 **二元回文**（binary）
时间限制：$ 2 \ sec$ ；空间限制：$256\  MB$

### 题目描述

如果一个字符串t正着读和反着读是一样的$（t[i] = t[|t|+1-i]~i\in[1,|t|]）$，那么这个字符串就是一个回文串。在这里$|t|$表示字符串$t$。

给你n个二进制字符串 $s_1,s_2,s_3, \dots, s_n$，每个字符串$s_i$都包含一些$0$和（或）一些$1$。你可以任意次数的调换这些字符串中的任意一对字符，当然也可以不调换。这一对字符中的两个字符可以来自同一个字符串，也可以来自不同的字符串，这没有限制。

在一次调换中：

- 选择四个整数$x,a,y,b$，保证$1\le x,y \le n~\&\&~1\le a\le |s_x|~\&\&~1 \le b \le |s_y|$  ( $x,y$是索引，$a,b$是在字符串$s_x,s_y$中的位置)
- 交换$s_x[a],s_y[b]$

那么通过这种交换我们最多可以得到多少个回文串呢？

------

现在给你$n$个二进制位字符串，可以交换这$n$个串中的任意两个字符（可以来自同一个串，也可以来自不同的串）。请你求出通过交换，最多可以构成多少个回文串。

### 输入格式

第一行包含单个整数 $Q ( 1 \le Q \le 50 )$ — 测试用例的数量。

每个测试用例的第一行包含单个整数 $n ( 1 \le n \le 50 )$ — 您拥有的二进制字符串的数量。

接下来的 n 行包含二进制字符串 $s_1, s_2, \dots, s_n$ — 每行一个。 保证 $1 \le |s_i| \le 50$且所有字符串均由零和/或一组成。

### 输出格式

打印 $Q$ 整数——每个测试用例一个。 第 $i$ 个整数应该是您可以同时对第 $i$ 个测试用例中的字符串执行零次或多次交换的最大回文字符串数。

### **输入 #1**

```
4
1
0
3
1110
100110
010101
2
11111
000001
2
001
11100111
```

### **输出 #1**

```
1
2
2
2
```

### 数据范围

对于$30\%$的数据

对于$100 \%$的数据$1 \le |s_i| \le 50;$  $1 \le Q \le 50 ;$  $1 \le n \le 50$

### 说明/提示

在第一个测试用例中，$s_1$是回文，所以答案是 $1$ 。

在第二个测试用例中，您不能同时使所有三个字符串都成为回文，但可以使任何一对字符串成为回文。 例如，让我们使 $s_1 = \text{0110}, s_2 = \text{111111}s $ 和 $s_3 = \text{010000}$

在第三个测试用例中，我们可以使两个字符串都回文。 例如，$s_1 = \text{11011}$和 $s_2 = \text{100001}$在最后一个测试用例 $s_2$是回文，你可以做 $s_1$回文，例如，通过交换 $s_1[2]$和 $s_1[3]$。

<div STYLE="page-break-after: always;"></div> 

## 3  **最小化整数**（integer）
时间限制：$2 \ sec$ ；空间限制：$256\  MB$

### 题目描述

给你一个大整数$a$，它由$n$位数字组成（$n$在$1$到$3 \times 10 ^ 5$之间）。它有可能会包含前导零。

你可以交换相邻位置的两个数字，如果这两个数字奇偶性不同（换言之，它们被二除的余数不同）。

举例来说：如果$a = 032867235$，你可以通过一次操作得到下面的整数：

- $302867235$ 如果你交换第一个和第二个数字
- $023867235$ 如果你交换第二个和第三个数字
- $032876235$ 如果你交换第五个和第六个数字
- $032862735$ 如果你交换第六个和第七个数字
- $032867325$ 如果你交换第七个和第八个数字

注意：你不能更换第二个和第四个数字，因为他们不相邻。你也不能更换第三个和第四个数字因为他们的奇偶性相同。

你可以做任意次操作（当然也可能不做）。

请你找到通过这种操作可以得到的最小整数。

注意答案也可以有前导零。

### 输入格式

第一行包含一个整数 $t ( 1 \le t \le 10^4) $ — 输入中的测试用例数。

每个测试用例的唯一一行包含整数 $a$ ，其长度 $n$ 介于 $1$ 和 $3 \cdot 10^5$ 之间，包含。

保证所有值$n$之和不超过$3 \cdot 10^5$.

### 输出格式

对于每个测试用例打印行 — 您可以获得的最小整数。

### **输入 #1**

```
3
0709
1337
246432
```

### **输出 #1**

```
0079
1337
234642
```

### 数据范围

对于$30\%$的数据

对于$100\%$ 的数据$1 \le t \le 10^4;$  $1 \leq n \leq 3\cdot 10^5$

### 说明/提示

在第一个测试用例中，您可以执行以下操作序列（交换的数字对突出显示）： $0 \underline{\textbf{70}} 9 \rightarrow 0079$.

在第二个测试用例中，初始整数是最优的。

在第三个测试用例中，您可以执行以下操作序列： $246 \underline{\textbf{43}} 2 \rightarrow 24 \underline{\textbf{63}}42 \rightarrow 2 \underline{\textbf{43}} 642 \rightarrow 234642$。



## 4 工资变动（salary）

时间限制：$3 \ sec$ ；空间限制：$256\  MB$

### 题目描述

您是一个大型企业的负责人（WoW）。在您的企业当中共有$n$位员工为您工作，而且非常有趣的事是这个$n$是一个奇数（$n$不能被$2$整除）。

您必须给你的员工分配工资。最初，您有$s$美元，而第$i$个员工应得的薪水应该是$l_i\sim r_i$之间的一个值。而无论怎么分配每个人的工资，您必须使得所有分配的工资的中位数最大。

对于一个长度为奇数的序列，如果要找到他的中位数，就需要先对这个序列进行排序，之后找到中间位置的数字。举例来说：

- 序列$[5,1,10,17,6]$的中位数是$6$
- 序列$[1,2,1]$的中位数是$1$

保证您有足够的钱来支付最低的工资，即$l_1+l_2+ \dots +l_n \le s$。

注意，您不必把所有的钱都花在员工的开支上。

一共有t组测试样例。

### 输入格式

第一行包含一个整数 $t ( 1 \le t \le 2 \cdot 10^5)$ — 测试用例的数量。

每个查询的第一行包含两个整数 $n$ 和 $s ( 1 \le n < 2 \cdot 10^5, 1 \le s \le 2 \cdot 10^{14})$ — 员工人数和您拥有的金额。 值 $n$ 不能被 $2$ 整除。

每个查询的以下 $n$ 行包含有关员工的信息。 第 $i$ 行包含两个整数 $l_i$和 $ r_i( 1 \le l_i \le r_i \le 10^9）$。

保证所有查询的所有 $n$ 的总和不超过 $2 \cdot 10^5$.

还保证您有足够的钱支付每位员工的最低工资，即。 e. $\sum\limits_{i=1}^{n} l_i \le s$。

### 输出格式

对于每个测试用例，打印一个整数——您可以获得的最大工资中位数。

### **输入 #1**

```
3
3 26
10 12
1 4
10 11
1 1337
1 1000000000
5 26
4 4
2 4
6 8
5 6
2 7
```

### **输出 #1**

```
11
1337
6
```

### 数据范围

对于$30\%$的数据

对于 $100\%$ 的数据 $1 \le t \le 2 \cdot 10^5;$  $1 \le n < 2 \cdot 10^5, 1 \le s \le 2 \cdot 10^{14};$  $ 1 \le l_i \le r_i \le 10^9;$  $\sum\limits_{i=1}^{n} l_i \le s$

### 说明/提示

在第一个测试用例中，您可以按如下方式分配工资：$sal_1 = 12、sal_2 = 2、sal_3 = 11$ ($sal_i$是第 $i $ 个雇员的工资）。 那么工资中位数是 $11$ 。

在第二个测试案例中，您必须向唯一的员工支付 $1337$ 美元。

在第三个测试用例中，您可以按如下方式分配工资：$sal_1 = 4、sal_2 = 3、sal_3 = 6、sal_4 = 6、sal_5 = 7$。 那么工资中位数是 $6$ 。
