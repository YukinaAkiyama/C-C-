
# CSP2021-训练-01

难度系数-$1250$​

**一．题目概况**

| 中文题目名称 |  数字序列划分  | 数字根 | 暴行 |  压缩  |
| :----------: | :-------: | :---------: | :-------: | :----------: |
| 可执行文件名 | divide.cpp | root.cpp | brutality.cpp | comp.cpp |
|  输入文件名  | divide.in | root.in | brutality.in | comp.in |
|  输出文件名  | divide.out | root.out | brutality.out | comp.out |
|   时间限制   |  1000ms  |   1000ms   |   1000ms   |  2500ms  |
|   空间限制   | 256M   |   256M   |   256M   |   256M    |

**二．注意事项：**
1、文件名（程序名和输入输出文件名）必须使用英文小写。
2、C/C++中函数main()的返回值类型必须是int，程序正常结束时的返回值必须是 0。
3、结果比较方式 ： 全文比较（过滤行末空格及文末回车）  。
4、特别提醒：评测在当前最新公布的 $NOI$ $Linux$ 下进行。
5、本次测试需要使用文件读写。

<div STYLE="page-break-after: always;"></div> 
## 1 数字序列划分  （divide）
时间限制：$ 1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

你有一个由 $n$个由 $0$到 $9$之间的数组成的序列 $s$

你必须最少把它分成两段,使得每一段组成的数字都比前一段组成的数字大。

输入第一行一个 $q$，表示询问的组数。

接下来有 $q$组询问，每一组询问第一行是一个整数 $n$，第二行为这个序列 $s$。

如果可以，输出 $YES$并且输出你的分割方案，否则，输出 $NO$

### 输入格式

输入的第一行包含一个整数 $q ( 1 \le q \le 300 ) $— 查询的数量。

第 $i$ 个查询的第一行包含一个整数 $n_i( 2 \le n_i \le 300)$ — 第 $i$ 个查询中的位数。

第 $i$ 个查询的第二行包含一个字符串 $s_i$ 长度为 $ n_i$仅由 $1$ 到 $9$ 的数字组成。

### 输出格式

如果第 i 查询中的数字序列不能以问题陈述中描述的方式至少分为两部分，则为该查询打印单行“NO”。

否则在这个查询的答案的第一行打印“YES”，在第二行打印 $k_i$—— 第 $i$ 个查询序列的划分中的部分数量，并在第三行打印 $k_i$字符串 $t_{i, 1}, t_{i, 2}, \dots, t_{i, k_i}$——你的部门。 零件应按初始字符串数字的顺序打印。 这意味着如果您一个接一个地编写部分而不改变它们的顺序，那么您将得到字符串 $s_i$.

请参阅示例以更好地理解。

### **输入 #1**
```
4
6
654321
4
1337
2
33
4
2122
```

### **输出 #1**
```
YES
3
6 54 321
YES
3
1 3 37
NO
YES
2
21 22
```

### 数据范围

### 

对于$30\%$的数据

对于$100\%$的数据  $1 \le q \le 300;$  $2 \le n_i \le 300$

<div STYLE="page-break-after: always;"></div> 

## 2 **数字根**（root）
时间限制：$ 1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

一个非负数的数字根由反复的数位和计算得来，每一次计算 使用前一次计算得来的结果计算数位和，直到计算结果为 $1$​ 位数为止。 若将x的数字根称作 $S(x)$​​，则 

$S(5)=5$​

$S(38)=S(3+8=11)=S(1+1=2)=2$

$S(10)=S(1+0=1)=1$

现在需要你找出数字根为 $x$的第 $k$个正数。（每个测试点有 $n$个这样的问题）

### 输入格式

第一行：一个整数 $n（1≤n≤10^3）$，表示该测试点的问题数

接下来的 $n$行，每行包含两个整数$k_i,x_i（1<=k_i<=10^12,1<=x_i<=9)$

表示对于第 $i$个问题，你需要找出数字根为 $x_i$的第 $k_i$个正数

### 输出格式

$n$ 行，第 $i$行包含一个整数：第 $i$个问题的答案

### **输入 #1**

```
3
1 5
5 2
3 1
```

### **输出 #1**

```
5
38
19
```

### 数据范围

对于$30\%$的数据

对于$100 \%$的数据  $1≤n≤10^3;$  $1<=k_i<=10^12,1<=x_i<=9$

<div STYLE="page-break-after: always;"></div> 

## 3  **暴行**（brutality）
时间限制：$1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

你在玩一个叫 **Kortal Mombat XII**  的游戏，你用电脑键盘玩这个游戏（用 $26$个字母键 $a-z$）。这个游戏中有一串攻击操作，对于每个攻击操作来说，他的伤害是 $a _i$ 而完成这次攻击操作需要按字母 $s_ i$ 。

但是你买的键盘质量不好，同样的一个键，每连续按 $k$ 次（按其他键时数量清零）就会爆炸，你不想让你的电脑爆炸，所以你只有一个办法：

· 跳过某些攻击操作使电脑不会爆炸

你想知道，所有对于第 $i$ 个攻击操作没被跳过时 $a_ i$ 的和最大是多少。

### 输入格式

第一行：$n,k$

第二行：$n$ 个数，$a_i$

第三行：$s$（$s_i$ 的字符串）

### 输出格式

最大的伤害

### **输入 #1**

```
7 3
1 5 16 18 7 2 10
baaaaca
```

### **输出 #1**

```
54
```

### **输入 #2**

```
5 5
2 4 1 3 1000
aaaaa
```

### **输出 #2**

```
1010
```

### **输入 #3**

```
5 4
2 4 1 3 1000
aaaaa
```

### **输出 #3**

```
1009
```

### 数据范围

对于$30\%$的数据

对于$100\%$​ 的数据  $1<=n , k <=200000;$​  $1<=a_ i <=1000000000$​

### 提示/说明

在第一个示例中，您可以选择数字为 $[1, 3, 4, 5, 6, 7]$ 的命中，总伤害为 $1 + 16 + 18 + 7 + 2 + 10 = 54$。

在第二个示例中，您可以选择所有命中，因此总伤害为 $2 + 4 + 1 + 3 + 1000 = 1010$ 。

在第三个示例中，您可以选择除第三个之外的所有命中，因此总伤害为 $2 + 4 + 3 + 1000 = 1009$ 。

在第四个示例中，您可以选择数字为 $[2, 3, 6, 8]$ 的命中。 只有这样你才能达到最大总伤害 $15 + 2 + 8 + 16 = 41$ 。

在第五个示例中，您只能选择数字为 $[2, 4, 6]$ 且总伤害为 $18 + 19 + 15 = 52$ 的命中。

在第六个示例中，您可以更改第一次命中或第二次命中（没关系），总伤害为 $10$ 。



## 4 压缩（comp）

时间限制：$2.5 \ sec$​ ；空间限制：$256\  MB$​

### 题目描述

给你一个 $n\times n$的矩阵。保证 $n$是 $4$的倍数。

现在，你需要找到一个新的矩阵，它的边长是 $\frac{n}{x}$​。对于所有的$1\leq i \leq n, 1 \leq j\leq n$​ 有 $a[i,j]=b[\lceil\frac{i}x\rceil,\lceil\frac{j}x\rceil]$​。

显然，当且仅当 $x|n$时能够找到这样的 $x$，但是，考虑这个矩阵：

​											$10$

​											$01$

当 $x=2$时，找不到这样的矩阵。

现在请对于一个给定的矩阵，求出最大的 $x$值。你不需要求出 $b$矩阵。

### 输入格式

第一行输入一个整数 $n$, 下面每一行包含 $\frac{n}{4}$个 $16$进制数字，每个数字表示这个矩阵的后 $4$个位置。例如，$B\to 1110, 5 \to 0101$. **没有空格隔开**

**请使用快读**

### 输出格式

打印一个数字：最大 $x$ ,使得给定矩阵的 $x$ 压缩是可能的。

### **输入 #1**

```
8
E7
E7
E7
00
00
E7
E7
E7
```

### **输出 #1**

```
1
```

### **输入 #2**

```
4
7
F
F
F
```

### **输出 #2**

```
1
```

### 数据范围

对于$30\%$的数据

对于 $100\%$ 的数据  $1\leq i \leq n, 1 \leq j\leq n;$  $4≤n≤5200$

### 提示/说明

第一个例子对应于矩阵：

​		$11100111$
​		$11100111$
​		$11100111$
​		$00000000$
​		$00000000$
​		$11100111$
​		$11100111$
​		$11100111$
很容易看出这个例子的答案是 $1$。

