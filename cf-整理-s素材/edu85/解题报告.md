

# CSP2021-J2-思维训练-01 解题报告

平均难度系数：$23.75$

| 题号 |    题目    | 难度系数 |     备注     |
| :--: | :--------: | :------: | :----------: |
| 1    |  游戏  | 20 |          数学          |
| 2    | 变换 | 20 |    贪心    |
| 3    |   怪兽   | 25 | 贪心、数学 |
| 4 | 回路 | 30 | 贪心、图论 |




<div STYLE="page-break-after: always;"></div> 

## 1 游戏
难度系数-$20$
### 解法分析 

首先，$p_i$ $ \ge c_i$，因为参加数肯定要超过通过数

其次，对于两个相邻的时间间隔，它的参加数和通过数肯定不能小于 00，也就是：$p_i \ge p_{i-1}$且 $c_i \ge c_{i-1}$。

最后，$p_i - p_{i-1}$ 一定要 $\ge c_i - c_{i-1}$，原理同第一种情况。参考代码

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;

template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int N = 1e2+ 50;
int t,n,p[N],c[N]; 

int main()
{
	read(t);
	while(t--)
	{
		read(n);bool k = 1;
		p[n] = 0;c[n] = 0;
		while(n--)
		{
			read(p[n]); read(c[n]);
			if(p[n] - p[n + 1] < c[n] - c[n + 1] || p[n] < p[n+1] || c[n] < c[n + 1] || p[n] < c[n])
				k = 0;
		}
		puts(k ? "YES" : "NO");
	}
	return 0;
}
```



<div STYLE="page-break-after: always;"></div> 

## 2 变换
难度系数-$20$
### 解法分析 

考虑贪心。首先求出所有数的平均值，然后每次去掉最小的那个数，这样平均值肯定会上涨。涨到这个平均值大于$x$的时候就可以输出解了。既然要去掉最小的数，可以使用优先队列来维护（在线），或者直接用sort*s**o**r**t*（离线），总时间复杂度$O(n\log_2 n)$。$n\le10^5$。

但是这里还有一个要注意的点，由于是要求平均值，所以至少要先把所有数加起来，由于$a_i\le 10^9,n\le10^5$，所以$sum \le 10^{14}$，需要$long long$。

### 参考代码

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;

template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int N = 1e5+ 50;
int t,n,m,ans,a[N];ll cnt; 

int main()
{
	read(t);
	while(t--)
	{
		ans = 0; cnt = 0;
		read(n); read(m);
		rep(i,1,n) read(a[i]);
		sort(a + 1,a + 1 + n);
		repd(i,n,1) 
		{
			if(a[i] + cnt < m) break;
			if(a[i] > m) cnt += a[i] - m;
			if(a[i] < m) cnt -= m - a[i];
			ans ++;
		}
		cout << ans << endl;
	}
	return 0;
}
```




<div STYLE="page-break-after: always;"></div> 

## 3 怪兽

难度系数-$25$

### 解法分析 

首先发现打死某一头怪兽有两种方法：1.直接打死 2.先打死前面一头，把怪兽炸残（或者直接炸死）再打死。

可以关注到显然第二种会更优，但是肯定要选择一头怪兽用第一种方案打死，再不断推进用第二种方式打死全部怪兽，所以我们设 $c_i$表示第 $i$ 头怪兽被炸之后还剩的血量，有 $c_i = \max (0, a_i - b_{i-1})$，特别的 $c_1=\max(0, a_1-b_n)$，然后枚举那个唯一的使用第一种方案打死的怪兽，找到最小的方案就行。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;
inline int read(){
	re int t=0;re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
int t,n,m,a[600002],ans,b[600002],pos;
signed main(){
	t=read();
	while(t--){
		n=read();
		for(re int i=1;i<=n;++i)a[i]=a[i+n]=read(),b[i]=b[i+n]=read();
		b[n+1]=b[1];a[n+1]=a[1];pos=0;re int mn=1e18,ans=0;
		for(re int i=1;i<=n*2-1;++i){
			if(b[i]>a[i+1])b[i]=a[i+1];
			if(b[i]<mn){
				mn=b[i];
				pos=i+1;
			}
		}
		for(re int i=pos;i<pos+n;++i){
			ans+=a[i];a[i+1]-=b[i];
		}
		printf("%lld\n",ans);
	}
}
```




<div STYLE="page-break-after: always;"></div> 

## 4 回路

难度系数-$30$

### 解法分析 

打表找规律

手推几个情况，发现答案是这样的（比如 n=4）

1,2,1,3,1,4,2,3,2,4,3,4,1

是由一系列连续的二元组组成的，最后末尾跟个 $1$。

我们可以算出 $l$ 这个位置当前处在哪个二元组里，往后推 $r-l+1$ 步即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		ll n,l,r;
		scanf("%lld%lld%lld",&n,&l,&r);
		ll a=1,b=1;
		while(((n-a)+(n-1))*a<l&&a<n) a++;
		while(((n-b)+(n-1))*b<r&&b<n) b++;
		if(a==n){
			printf("1\n");
			continue;
		}
		l-=(n*2-a)*(a-1);
		r-=(n*2-b)*(b-1);
		if(a==b){
			for(ll i=l;i<=r;i++){
				if(i&1) printf("%lld ",a);
				else{printf("%lld ",(i/2+a));}
			}
			printf("\n");
			continue;
		}
		for(ll i=l;i<=(n-a)*2;i++){
			if(i&1) printf("%lld ",a);
			else{printf("%lld ",(i/2+a));}
		}
		ll t=a+1;
		while(t<=b-1){
			for(ll i=t+1;i<=n;i++){
				printf("%lld %lld ",t,i);
			}
			t++;
		}
		if(b==n){
			printf("1\n");
			continue;
		}
		for(ll i=1;i<=r;i++){
			if(i&1) printf("%lld ",b);
			else{printf("%lld ",(i/2+b));}
		}
		printf("\n");
		
	}
	
}
```
