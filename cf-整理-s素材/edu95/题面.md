
# CSP2021-训练-01

难度系数-$26.4$

**一．题目概况**

| 中文题目名称 |    买火把    | 负前缀 | 凡人孔巴特塔 | 垃圾问题 |
| :----------: | :-------: | :---------: | :-------: | :----------: |
| 可执行文件名 | torches.cpp | prefixes.cpp | mortal.cpp | trash.cpp |
|  输入文件名  | torches.in | prefixes.in | mortal.in | trash.in |
|  输出文件名  | torches.out | prefixes.out | mortal.out | trash.out |
|   时间限制   |  1000ms   |   2000ms   |  1000ms  | 3000ms |
|   空间限制   | 256M   |   256M   |   256M    | 256M |

**二．注意事项：**
1、文件名（程序名和输入输出文件名）必须使用英文小写。
2、C/C++中函数main()的返回值类型必须是int，程序正常结束时的返回值必须是 0。
3、结果比较方式 ： 全文比较（过滤行末空格及文末回车）  。
4、特别提醒：评测在当前最新公布的 $NOI$ $Linux$ 下进行。
5、本次测试需要使用文件读写。

<div STYLE="page-break-after: always;"></div> 
## 1 买火把（Buying Torches）
时间限制：$1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

- 你要获得 $k$ 个火把，最开始你有 $1$根木棒。一个木棒和一个煤炭可以合成一个火把，你也可以通过两种交易方式得到木棒或煤炭：

  1. 通过**给**商人 $1$根木棒，获得$ x $根木棒。
  2. 通过**给**商人$ y$ 根木棒，获得 $1$个煤炭。

  其中$ 2\leq x\leq 10^{9};1\leq y,k\leq 10^{9}$。

  求得到$ k$个火把的最少交易次数。

### 输入格式

输入的第一行包含一个整数$ t (1≤t≤2⋅10^{4})$——测试用例的数量。 然后是 t 测试用例。

测试用例的唯一一行包含三个整数$x、y$和$k（2≤x≤10^{9}；1≤y，k≤10^{9}）$——分别表示：一根棍子可以买多少根木棒、购买一块煤所需的木棒数量、和你需要的火火把数量。

### 输出格式

对于每个测试用例，打印答案：制作至少 $k$ 火把所需的最少交易次数。 答案总是在给定的约束下存在。

### **输入 #1**
```
5
2 1 5
42 13 24
12 11 12
1000000000 1000000000 1000000000
2 1000000000 1000000000
```

### **输出 #1**
```
14
33
25
2000000003
1000000001999999999
```

### 数据范围

### 

对于$100\%$的数据满足$ 2\leq x\leq 10^{9};1\leq y,k\leq 10^{9};$ $1≤t≤2⋅10^{4};$ $2≤x≤10^{9};1≤y，k≤10^{9}$



<div STYLE="page-break-after: always;"></div> 

## 2 负前缀（Negative Prefixes）
时间限制：$ 2 \ sec$ ；空间限制：$256\  MB$

### 题目描述

题目给出 $n$ 组数据，对于每一组数据：

给你一个长度为 $n$ 的数组，这个数组中的每一个数都有一个状态，或者是$ 0$，或者是 $1$。

$1$代表这个数字是上锁了的，无法变换位置，而 $0$则代表这个数字没被上锁，可以和其他标为 $0$ 的数交换位置。

现在要使得 $k$最大，而$ k$ 需要满足前$ k$ 个数之和小于$ 0$ ,否则$ k=0$。

输出一种使 $k$最大的方案。

### 输入格式

第一行包含一个整数$ t (1≤t≤1000)$——测试用例的数量。

然后是测试用例。

每个测试用例的第一行包含一个整数 $n (1≤n≤100)$——数组 a 中元素的数量。

每个测试用例的第二行包含$ n$ 个整数 $a_1,a_2,…,a_n (−10^{5}≤a_i≤10^{5})$——初始数组 a。

每个测试用例的第三行包含$n $个整数$ l_1,l_2,…,l_n (0≤l_i≤1)$，其中$ l_i=0 $表示位置$ i $未锁定，$l_i=1 $表示位置$i $锁定。

### 输出格式

打印 $n$ 个整数——重排后的数组 $a$。 值$ k$（最大$ j$使得 $p_j < 0$（或 $0$如果没有这样的$ j $））应该是最小的。 对于每个锁定位置，打印值应等于初始值。 解锁位置的值应该是初始值的排列。

如果有多个答案，则打印其中任何一个。

### **输入 #1**

```
5
3
1 3 2
0 0 0
4
2 -3 4 -1
1 1 1 1
7
-8 4 -2 -6 4 7 1
1 0 0 0 1 1 0
5
0 1 -4 6 3
0 0 0 1 1
6
-1 7 10 4 -8 -1
1 0 0 0 0 1
```

### **输出 #1**

```
1 2 3
2 -3 4 -1
-8 -6 1 4 4 7 -2
-4 0 1 6 3
-1 4 7 -8 10 -1
```

### 数据范围

对于$100 \%$的数据满足$1≤t≤1000;$ $1≤n≤100;$ $−10^{5}≤a_i≤10^{5}; $ $0≤l_i≤1$

### 说明/提示

在第一个测试用例中，您可以根据需要重新排列所有值，但任何排列都会导致 $k=0$。 例如，对于排列$ [1,2,3]，p=[1,3,6]，$所以没有$ j$ 使得$ p_j<0$。 因此，$k=0$。

在第二个测试用例中，您不允许重新排列任何元素。 因此，打印的数组应该与初始数组完全相同。

在第三个测试用例中，打印数组的前缀和是 $p=[-8,-14,-13,-9,-5,2,0]$。 最大$ j$ 为$ 5$，因此 $k=5$。 不存在$ k<5$ 的安排。

在第四个测试用例中，$p=[−4,−4,−3,3,6]$。

在第五个测试用例中，$p=[−1,3,10,2,12,11]$。

<div STYLE="page-break-after: always;"></div> 

## 3  凡人孔巴特塔（Mortal Kombat Tower）
时间限制：$ 1 \ sec$ ；空间限制：$256\  MB$

### 题目描述

给出 t 组数据，对于每一组数据：

给定一个长度为 n的 01 数组，先后手轮流取数，每次可以取 1或 2个数。

先后手都需要最小化先手取到 11 的数量，输出这个值。

$1\leq t\leq 2\cdot10^4,1\leq n\leq 2\cdot10^5\leq a_i\leq 1,\sum n \leq 2 \cdot 10^5$

### 输入格式

输入的第一行包含一个整数$ t( 1 \le t \le 2 \cdot 10^4 )$ — 测试用例的数量。 然后是$ t$ 测试用例。

测试用例的第一行包含一个整数 $n( 1 \le n \le 2 \cdot 10^5) $— 老板的数量。 测试用例的第二行包含$n$个整数$a_1, a_2, \dots, a_n$$ ( 0 \le a_i \le 1)$，其中 $a_i$是第$i$个boss的类型。

保证$n$之和不超过$2 \cdot 10^5 ( \sum n \le 2 \cdot 10^5）$。

### 输出格式

对于每个测试用例，打印答案：您的朋友需要使用的最小跳过点数，以便您和您的朋友按照给定的顺序杀死所有 $n $个 Boss。

### **输入 #1**

```
6
8
1 0 1 1 0 1 1 1
5
1 1 1 1 0
7
1 1 1 1 0 0 1
6
1 1 1 1 1 1
1
1
1
0
```

### **输出 #1**

```
2
2
2
2
1
0
```

### 数据范围

对于 $100\%$ 的数据，$1\leq t\leq 2\cdot10^4,1\leq n\leq 2\cdot10^5\leq a_i\leq 1,\sum n \leq 2 \cdot 10^5;$ $1 \le t \le 2 \cdot 10^4;$ $1 \le n \le 2 \cdot 10^5;$ $0 \le a_i \le 1;$ $\sum n \le 2 \cdot 10^5$

## 4 垃圾问题（Trash Problem）

时间限制：$3 \ sec$ ；空间限制：$256\  MB$

### 题目描述

- 数轴上有$ n$ 个点，定义代价为将所有点移动到不超过两个整点的距离和

  有$ q $次操作，你需要每次删除或者插入一个点，在第一次操作前，以及每一次操作后回答最小代价

### 输入格式

输入的第一行包含两个整数$ n$ 和 $q (1≤n,q≤10^{5})$——分别是所有查询之前房间中的桩数和查询的数量。

输入的第二行包含 $n $个不同的整数$ p_1,p_2,…,p_n (1≤p_i≤10^{9})$，其中$ p_i $是第$ i $堆的坐标。

接下来的 $q$ 行描述了查询。 第$ i $个查询用两个整数 $t_i$ 和$ x_i$ 描述$（0≤t_i≤1；1≤x_i≤10^{9}）$，其中如果需要从坐标 $x_i$ 中删除一堆，则 $t_i$ 为$ 0$，如果需要添加则为$ 1$ 一堆到坐标$x_i$。 保证$ t_i=0 $在当前桩组中有这样的桩，对于 $t_i=1$ 在当前桩组中没有这样的桩。

### 输出格式

打印 $q+1 $个整数：在第一次查询之前和每个$ q $查询之后，Vova 需要进行总清理的最小移动次数。

### **输入 #1**

```
5 6
1 2 6 8 10
1 4
1 9
0 6
0 10
1 100
1 50
```

### **输出 #1**

```
5
7
7
5
4
8
49
```

### **输入 #2**

```
5 8
5 1 2 4 3
0 1
0 2
0 3
0 4
0 5
1 1000000000
1 1
1 500000000
```

### **输出 #2**

```
3
2
1
0
0
0
0
0
499999999
```

### 数据范围

对于 $100\%$ 的数据$1≤n,q≤10^{5};$ $1≤p_i≤10^{9};$ $0≤t_i≤1；1≤x_i≤10^{9};$ 



## 解释

考虑第一个例子。

最初，桩的集合是 $[1,2,6,8,10]$。第一个查询之前的答案是 $5$，因为您可以将所有桩从 $1 $移动到 $2 $一步，所有桩从$ 10 $移动到 $8 $以$ 2 $步移动，所有桩从$ 6 $到 $8 $以 $2 $步移动。

第一次查询后，集合变为 $[1,2,4,6,8,10]$。那么答案是$ 7$，因为你可以用 $2$ 步将所有堆从 $6$ 移到 $4$，所有堆从$ 4 $移到$ 2 $步，移$ 2 $步，所有堆从$ 2 $移到$ 1 $步，移 $1$ 步，所有堆从 $10 $移到 8 步，移 $2 $步。

第二次查询后，堆集变为$ [1,2,4,6,8,9,10] $并且答案相同（并且可以将之前的移动序列应用于当前的堆集）。

第三次查询后，堆集变成$[1,2,4,8,9,10]$，答案是$5$，因为你可以用$1$次移动所有从$1$到$2$的桩，用$2$移动所有从$2$到$4$的桩移动，所有从$ 10 $到$9 $的桩都移动$ 1$ 步，所有从$ 9 $到 $8$ 的桩都移动 $1 $步。

在第四次查询之后，集合变为 $[1,2,4,8,9] $并且答案几乎相同（可以应用前面的移动序列，而无需从 $10 $移动桩）。

第五次查询后，集合变为 $[1,2,4,8,9,100]$。您可以将所有桩从 $1 $和进一步移动到 $9$，并将$ 100$ 保持在其位置。所以答案是$8$。

第六次查询后，集合变为$ [1,2,4,8,9,50,100]$。答案是$ 49$，并且可以通过与上一个查询几乎相同的移动序列来获得。唯一的区别是您还需要将所有桩从$ 50$ 移动到$ 9$。

