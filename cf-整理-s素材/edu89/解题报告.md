

# CSP2021-J2-思维训练-01 解题报告

平均难度系数：$28.50$

| 题号 |    题目    | 难度系数 |     备注     |
| :--: | :--------: | :------: | :----------: |
| 1    |  多边形  | 20 |          贪心          |
| 2    |   序列   | 25 |    排序    |
| 3    |   加数   | 25 | 贪心、数学 |
| 4 | 统计 | 30 | 数学、组合 |
| 5    |  数组收缩  | 30 | 区间dp |




<div STYLE="page-break-after: always;"></div> 

## 1 多边形
难度系数-$20$
### 解法分析 

较为基础的贪心题目,如果后者多边形边数是前者的因数则满足题意


### 参考代码

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;

template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

int main()
{
	int t;
	cin >> t;
	while(t --)
	{
		int n,m;
		read(n); read(m);
		puts(n % m == 0 ? "YES" : "NO");
	}
	return 0;
}
```



<div STYLE="page-break-after: always;"></div> 

## 2 序列
难度系数-$25$
### 解法分析 

因为 $i$ 严格单调递增，于是我们考虑让 $a$ 单调不增，这样$i-a[i]$就严格单调递减，其为对于任意$i,j(i\not =j\&\&i,j<=n),i-a[i]\not=j-a[j]$的充分条件。

### 参考代码

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;

template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

int n,a[101];

int main()
{
	int t;
	cin >> t;
	while(t --)
	{
		read(n);
		rep(i,1,n) read(a[i]);
		sort(a + 1,a + 1 + n);
		repd(i,n,1) printf("%d ",a[i]);
		puts("");
	}
	return 0;
}
```




<div STYLE="page-break-after: always;"></div> 

## 3 加数

难度系数-$25$

### 解法分析 

此题贪心依次将数从大到小看看能不能被$k^i$相加得到

### 参考代码

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;
 
template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}
 
int n,k;
bool vis[31];
priority_queue<ll> q;
int main()
{
	int t;
	cin >> t;
	while(t --)
	{
		read(n); read(k); 
		ll x,MAX = 1; 
		rep(i,1,n) 
		{
			read(x);
			if(x) q.push(x);
			MAX = max(MAX,x);
		}
		x = 1;
		while(x * k <= MAX) x *= k;
		while(x && !q.empty())
		{
			if(q.top() >= x)
			{
				ll z = q.top(); 
				q.pop(); z-= x; 
				if(z) q.push(z);
			}
			 
			x /= k;
		}
		puts(q.empty() ? "YES" : "NO");
		while(!q.empty()) q.pop();
	}
	return 0;
}
```




<div STYLE="page-break-after: always;"></div> 

## 4 统计

难度系数-$30$

### 解法分析 

$C^{n-1}_{m} * 2^{n-2} *(n-2)* \frac{1}{2}$

```cpp
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;

template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int mod = 998244353,N = 2e5 + 50;
int n,m;

int quick_pow(int x,int y)
{
	int ans = 1;
	while(y)
	{
		if(y&1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod; y >>= 1;
	}
	return ans;
}

int f[N];

int main()
{
	read(n); read(m);
	f[1] = 1;
	rep(i,2,m) f[i] = 1ll * f[i-1] * i % mod;
	if(n == 2) cout << 0 ;
	else cout << 1ll * f[m] *quick_pow(f[n-1],mod-2)%mod * quick_pow(f[m-n+1],mod - 2)%mod * (n-2) %mod *quick_pow(2,n - 3) % mod;
	return 0;
}
```

## 5 数组收缩

难度系数-$30$

$f[i][j]$表示 $i$ 到 $j$ 最短能压缩成的长度

$m[i][j]$ 表示 $i$ 到 $j$ 压缩成一个数的值

根据题目转移式为

$f[i][j] = min(f[i][j],f[i][k-1] + f[k][j]);$
$if(f[i][k - 1] == 1 \&\& f[k][j] == 1 \&\& m[i][k - 1] == m[k][j])$
			$		f[i][j] = 1,m[i][j] = m[k][j] + 1;$

### 解法分析 

```
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x; i >= y ; -- i) 
using namespace std;
typedef long long ll;
 
template<typename T>inline void read(T&x)
{
	int sign = 1; x = 0; char c;
	do { c = getchar (); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}
 
const int N = 5e2 + 50;
int n;
int a[N],m[N][N],f[N][N];
 
int main()
{
	read(n);
	
	rep(i,1,n) read(a[i]);
	
	memset(f,0x3f,sizeof f);
	rep(i,1,n) f[i][i] = 1,m[i][i] = a[i];
	
	repd(i,n,1) rep(j,i + 1,n) rep(k,i + 1,j)
	{
		f[i][j] = min(f[i][j],f[i][k-1] + f[k][j]);
		if(f[i][k - 1] == 1 && f[k][j] == 1 && m[i][k - 1] == m[k][j])
			f[i][j] = 1,
			m[i][j] = m[k][j] + 1;
	}
	
	cout << f[1][n] << endl;
	
	return 0;
}