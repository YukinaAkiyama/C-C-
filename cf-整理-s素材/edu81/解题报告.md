

# CSP2021-J2-思维训练-01 解题报告

平均难度系数：$28.50$

| 题号 |    题目    | 难度系数 |     备注     |
| :--: | :--------: | :------: | :----------: |
| 1    |  显示数字  | 25 |          贪心          |
| 2    | 无限前缀 | 30 | 排序、二分     |
| 3    | 获取字符串 | 25 | 动态规划、字符串、贪心 |
| 4 | 相同gcd | 24 | 数学 |
| 5    |  排列分离  | 30 | 线段树 |




<div STYLE="page-break-after: always;"></div> 

## 1 显示数字
难度系数-$25$
### 解法分析 

较为基础的贪心题目,如果是奇数先填一个7再全部填1，如果是偶数只用填1，读清题意，注意细节即可。


### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n , t , x;
	cin >> t;
	while(t --)
	{
		cin >> n; x = n / 2;
		if(n&1) cout << 7 , -- x;
		while( x --) cout << 1;
		cout << endl;
	}
	return 0;
}
```



<div STYLE="page-break-after: always;"></div> 

## 2 无限前缀
难度系数-$30$
### 解法分析 

首先考虑无限解的情况，同时考虑空串的特殊情况，剩下的根据s的前缀的每一种情况一一判断即可

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s; 
int n ,t ,x ,mi ,mx ,cnt ,ans;
const int N = 1e5 + 50;
int vis[2*N],num[2*N];
int main()
{

	cin >> t;
	for(int i = 1;i <= t; ++ i)
	{
		cin >> n >> x;
		cin >> s; x += N;
		ans = 0; cnt = N ;
		mi = N + 1,mx = N - 1;
		for(auto j : s)
		{
			cnt += j =='0' ? 1 : -1;
			if(vis[cnt] == i) ++ num[cnt] ;
			else vis[cnt] = i,num[cnt] = 1;
			mi = min(mi,cnt); mx = max(mx,cnt);
		}
		if(x == N) ans = 1;
		if(cnt == N) puts(mx >= x && mi <= x ? "-1" : "0");
		else 
		{
			for(int j = mi;j <= mx; ++ j)
				if((x - j) % (cnt - N) == 0 && (x-j)/ (cnt-N) >= 0)
					ans += num[j];
			cout << ans << endl;
		}
	}
	return 0;
}
```




<div STYLE="page-break-after: always;"></div> 

## 3 获取字符串

难度系数-$25$

### 解法分析 

此题贪心依次取字母到不能取以后再重新开始取就可解决，注意判无解的情况。

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 4; 
string s,t;
int T,nxt[N][26];
int main()
{
	cin >> T;
	while(T--)
	{
		cin >> s;
		cin >> t;
		int l1 = s.length();
		for(int i = 0;i <= 25;++ i) nxt[l1-1][i] = -1;
		for(int i = l1 - 1;i;--i)
		{
			for(int j = 0; j <= 25; ++ j)
				nxt[i-1][j] = nxt[i][j];
			nxt[i-1][s[i] - 'a'] = i;
		}
		int l2 = t.length(); int ans = 1,now = l1;
		for(int i = 0;i <= 25;++ i) nxt[now][i] = nxt[0][i]; nxt[now][s[0] - 'a'] = 0;
		for(int i = 0;i < l2; ++ i)
		{
			int x = t[i] - 'a';
			if(nxt[l1][x] == -1) { ans = -1; break; }
			if(nxt[now][x] == -1) ++ ans, now = nxt[l1][x];
			else now = nxt[now][x];
		}
		cout << ans << endl;
		
		for(int i = l1 - 1;i >= 0;--i)
			for(int j = 0; j <= 25; ++ j)
				nxt[i][j] = 0;
	}
	return 0;
}
```




<div STYLE="page-break-after: always;"></div> 

## 4 相同gcd

难度系数-$24$

### 解法分析 

令 $d=\gcd(a,m)$，则有 $\gcd(\frac{a}{d},\frac{m}{d})=1$，所以题意就是求 $phi(\frac{m}{d})$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll gcd(ll x, ll y) { return y ? gcd(y,x%y) : x; } 

inline ll phi(ll x){
	ll ans=x;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			ans=ans/i*(i-1);
			while(x%i==0)x/=i;
		}
	}
	if(x>1)ans=ans/x*(x-1);
	return ans;
}

int main()
{
	int t;
	cin >> t;
	while(t --)
	{
		ll m,a;
		cin >> a >> m;
		cout << phi(m / gcd(a,m )) << endl;
	}
	return 0;
}
```

## 4 排列分离

难度系数-$30$

### 解法分析 

首先有一个比较显然的暴力做法，我们设定一个边界值$x$，然后枚举两个集合的分界点，在第一个集合中查询数值在$[x+1,n]$之间的权值和，在第二个集合中查询$[1,x]$的和，加起来取$min$

但这显然是不能过的，我们考虑逐渐增大边界值$x$，同时用一种数据结构来维护第$i$个位置为分界点时的花费，接下来我们发现增大边界值可以看成在区间加，维护花费是区间$min$，可以使用线段树来维护，复杂度$O(nlogn)$

细节注意要开$long long$

```
#include <bits/stdc++.h>
#define rep(i,x,y) for(register int i = x ;i <= y; ++ i)
using namespace std;
typedef long long ll;
const int N = 4e5+5;
struct segment_tree
{
	ll mi[N << 2],lzy[N << 2];
	
	inline void put_down(int id)
	{
		mi[id] += lzy[id];
		lzy[id << 1] += lzy[id];
		lzy[id << 1|1] += lzy[id];
		lzy[id] = 0;
	}
	
	void add(int id,int l,int r,int L,int R,ll w)
	{
		put_down(id);
		if(l == L&& R == r)
		{
			lzy[id] = w;
			put_down(id);
			return ;
		}
		int mid = l +  r>> 1;
		if(R <= mid) add(id<<1,l,mid,L,R,w);
		else if(L > mid) add(id<<1|1,mid+1,r,L,R,w);
		else add(id<<1,l,mid,L,mid,w),add(id<<1|1,mid+1,r,mid+1,R,w);
		mi[id] = min(mi[id<<1],mi[id<<1|1]);
	}
}t;
int p[N],a[N],id[N];
const bool cmp(int x,int y) { return p[x] < p[y]; }
int main()
{
	int n;
	cin >> n;
	rep(i,1,n) cin >> p[i];
	rep(i,1,n) cin >> a[i];
	rep(i,1,n) id[i] = i;
	
	ll res = 0;
	rep(i,1,n)
	{
		res += a[i];
		t.add(1,1,n,i,i,res);
	}
	sort(id + 1,id + 1 + n,cmp);
	
	ll ans = t.mi[1];
	rep(i,1,n)
	{
		int x = id[i]; 
		if(x != n) t.add(1,1,n,x,n,-a[x]);
		if(x != 1) t.add(1,1,n,1,x-1,a[x]);
		ans = min(ans,t.mi[1]);
	}
	
	cout << ans << endl;
	return 0;
}